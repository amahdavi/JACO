#ifndef SZ_JACO_INTERFACE_H
#define SZ_JACO_INTERFACE_H

#define SZC "SZ Code Copright (C) 2013 Seth Siegel and Jack Sayers\n"

/* headers needed to compile this header */
#include "fftw3.h"

/* structure declarations */
struct BigSZControlParams
{
	int ndataset;								/* This is the total number of SZ data sets that will be jointly fit.  It is set by the calling program. */

	char **paramfiles;							/* This is an array of ndataset strings, with index 0 to ndataset-1.  It is set by the calling program.
												Each string contains the name of a file describing one SZ observation.  This must be a .fits file of the correct
												format, containing extension (1). Image, (2). Pixel RMS, (3). Real Component of the Transfer Function,   
												(4). Imaginary Component of Transfer Function. */

	double *deccent;							/* 1D arrays of size ndataset, they contain the central RA, central DEC, pixel size, */
	double *racent;								/* and dimension of each model image.  They are set by big_initialize_sz.  JACO will make corrected y-maps */
	double *pixsize;							/* with these dimensions. */
	int *npix;

												/* 1D arrays of size ndataset, they contain: */
	int *scaling_factor;						/*		Resolution of the data divided by the resolution of the model image */
	int *npix_data;								/*		Dimension of the data. */
	double *rmax;								/*		Maximum radius (degrees) from the center of the image that should be fit. */
	double *unit_conversion;					/*		Conversion from compton y to uK_CMB. */
	double *sum_inverse_variance;				/*		Sum of (1 / Pixel RMS)^2 for all pixels within rmax from the center of the image. */
	double *delta_T;							/*		Best fit DC offset of the image. */
												/* and are derived from quantities stored in the header of the fits file.  All of the arrays are filled in by 
												/* big_initialize_sz, except for delta_T, which is filled in by big_get_sz_model. */

	double **coverage_mask;						/* A list of pointers to the real components of pixels in fft_data that are within rmax from the center of the image. */

	fftw_plan *fft_model_plan_forward;			/* An array of ndataset plans generated by fftw for performing complex, 2D in-place forward FFTs on images the size of the model (npix x npix). */
	fftw_plan *fft_model_plan_backward;			/* An array of ndataset plans generated by fftw for performing complex, 2D in-place backward FFTs on images the size of the model (npix x npix). */

	fftw_plan *fft_data_plan_forward;			/* An array of ndataset plans generated by fftw for performing complex, 2D in-place forward FFTs on images the size of the data (npix_data x npix_data). */
	fftw_plan *fft_data_plan_backward;			/* An array of ndataset plans generated by fftw for performing complex, 2D in-place backward FFTs on images the size of the data (npix_data x npix_data). */

	fftw_complex ***fft_model;					/* A 3D complex tensor of size ndataset x npix x npix.  Both fft_model_plan_forward and fft_model_plan_backward operate on this tensor. */

	fftw_complex ***fft_data;					/* A 3D complex tensor of size ndataset x npix_data x npix_data.  Both fft_data_plan_forward and fft_data_plan_backward operate on this tensor. */

	fftw_complex ***fft_beam;					/* A 3D complex tensor of size ndataset x npix x npix that will be filled with the fft of the beam kernel during big_initialize_sz. */

	fftw_complex ***signal_transfer_function;	/* A 3D complex tensor of size ndataset x npix x npix that will be filled with the transfer function of the bolocam pipeline during big_initialize_sz. */

	int *nest_per_dataset;						/* Number of data points for each of the datasets. */
	int nest;									/* Total number of data points. */
	double *data;								/* All of the SZ images concatenated into a vector of length nest. */
	double *errors;								/* All of the SZ RMS maps concatenated into a vector of length nest. */
	double *models;								/* All of the SZ models concatenated into a vector of length nest.  Updated at each call to big_get_sz_model. */

	double ***ymap;								/* A 3D tensor of size ndataset x npix x npix that JACO will fill with the correct y values after big_initialize_sz. */

	int node;									/* Multiple codes of JACO will be running simultaneously; this provies a unique identifier to the currently running copy. */

	int quiet;									/* Suppress all non-error messages if this is not 0. */
};

struct BigSZKeywords
{
	int npix;					
	double fwhm;				/* degrees */
	double sigma;				/* degrees */
	double pixsize;				/* degrees */
	double rmax;				/* degrees */
	double unit_con;			/* y per uK_CMB */
	char ctype1[9];				/* RA---SFL or DEC--SFL */
	char ctype2[9];				/* RA---SFL or DEC--SFL */
	double cd1;					/* degrees/pixel for dim1 */
	double cd2;					/* degrees/pixel for dim2 */
	double crpix1;				/* Center pixel number for dim1 */
	double crpix2;				/* Center pixel number for dim2 */
	double crval1;				/* Center pixel value in degrees for dim1 */
	double crval2;				/* Center pixel value in degrees for dim2 */
	int scaling_factor;
};

/* function prototypes */
int big_get_sz_model(double *models, struct BigSZControlParams *params);
int big_initialize_sz(struct BigSZControlParams *ptr_to_szstruct);
int free_big_sz(struct BigSZControlParams *psz);

int error_check_bolocam_fits_file(const char *fits_file, int *npix, double *rmax);
int read_bolocam_fits_file_keywords(const char *fits_file, struct BigSZKeywords *ptr_to_keywords);
int read_bolocam_fits_file(const char *fits_file, double *data, double *errors, fftw_complex **transfer_function, int npix);
int define_sz_model_map(struct BigSZKeywords *pkey);
int generate_bolocam_beam_kernel(fftw_complex **beam, struct BigSZKeywords key);
int count_pixels_within_aperture(int nx, int ny, double x0, double y0, double rmax);
int zero_pad_sz(fftw_complex **map, int nx1, int nx2, int ny1, int ny2);

int allocate_double_matrix_contiguous(double ***matrix, int nrows, int ncols);
int free_double_matrix_contiguous(double ***matrix);
int allocate_fftw_complex_matrix_contiguous(fftw_complex ***matrix, int nrows, int ncols);
int free_fftw_complex_matrix_contiguous(fftw_complex ***matrix);

#endif
